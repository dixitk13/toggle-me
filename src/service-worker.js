// Set this to true for production
var doCache = true;

// constants
const version = "0.1.1";
const cacheName = `toggle-me-${version}`;
const runtime = "runtime";

// dumb start
//
// self.addEventListener("load", () => {
//   console.log("service worker load?");
// });
//
// self.addEventListener("install", event => {
//   let timeStamp = Date.now();
//
//   console.log(`install-ing @ ${timeStamp}`);
//   event.waitUntil(
//     caches
//       .open(cacheName)
//       .then(cache => cache.addAll(cacheUrls))
//       .then(self.skipWaiting())
//   );
// });
//
// // The activate handler takes care of cleaning up old caches.
// self.addEventListener("activate", event => {
//   const currentCaches = [cacheName, runtime];
//   event.waitUntil(
//     caches
//       .keys()
//       .then(cacheNames => {
//         return cacheNames.filter(
//           cacheName => !currentCaches.includes(cacheName)
//         );
//       })
//       .then(cachesToDelete => {
//         return Promise.all(
//           cachesToDelete.map(cacheToDelete => {
//             return caches.delete(cacheToDelete);
//           })
//         );
//       })
//       .then(() => self.clients.claim())
//   );
// });
//
// // The fetch handler serves responses for same-origin resources from a cache.
// // If no response is found, it populates the runtime cache with the response
// // from the network before returning it to the page.
// self.addEventListener("fetch", event => {
//   // Skip cross-origin requests, like those for Google Analytics.
//   if (event.request.url.startsWith(self.location.origin)) {
//     event.respondWith(
//       caches.match(event.request).then(cachedResponse => {
//         if (cachedResponse) {
//           return cachedResponse;
//         }
//
//         return caches.open(runtime).then(cache => {
//           return fetch(event.request).then(response => {
//             // Put a copy of the response in the runtime cache.
//             return cache.put(event.request, response.clone()).then(() => {
//               return response;
//             });
//           });
//         });
//       })
//     );
//   }
// });
//
// // dumb end

// let assetsToCache = ["./index.html"];
//
// assetsToCache = assetsToCache.map(path => {
//   return new URL(path, global.location).toString();
// });

// Delete old caches that are not our current one!
self.addEventListener("activate", event => {
  console.log("activate event called");
  const cacheWhitelist = [cacheName];
  event.waitUntil(
    caches.keys().then(keyList =>
      Promise.all(
        keyList.map(key => {
          if (!cacheWhitelist.includes(key)) {
            console.log("Deleting cache: " + key);
            return caches.delete(key);
          }
        })
      )
    )
  );
});

// A list of local resources we always want to be cached.
const cacheUrls = [
  // "index.html",
  "./toggle-icon-144.png",
  "./toggle-icon.png",
  "./toggle-icon-white.png",
  "./favicon.ico"
];

// The first time the user starts up the PWA, 'install' is triggered.
self.addEventListener("install", function(event) {
  console.log("install event called");
  if (doCache) {
    event.waitUntil(
      caches.open(cacheName).then(function(cache) {
        // Get the assets manifest so we can see what our js file is named
        // This is because webpack hashes it
        fetch("asset-manifest.json")
          .then(response => response.json())
          .then(assets => {
            // Open a cache and cache our files
            // We want to cache the page and the main.js generated by webpack
            // We could also cache any static assets like CSS or images
            console.log("assets cached ", assets);
            const manifestFiles = (Object.values(assets) || [])
              .filter(x => x !== "./service-worker.js")
              .filter(y => !cacheUrls.includes(y));
            const allCaches = [...(cacheUrls || []), ...manifestFiles];
            cache.addAll(allCaches);
            console.log("cached ", allCaches);
          });
      })
    );
  }
});

self.addEventListener("fetch", function(event) {
  console.log("fetch event called for", event.request.url);

  event.respondWith(
    caches.match(event.request).then(function(response) {
      if (response) {
        console.log("Found response in cache:", response);

        return response;
      }

      console.log("No response found in cache. About to fetch from network...");

      return fetch(event.request)
        .then(function(response) {
          console.log("Response from network is:", response);

          return response;
        })
        .catch(function(error) {
          console.error("Fetching failed:", error);

          return caches.match("./index.html");
        });
    })
  );
});

let deferredPrompt = undefined;

self.addEventListener("beforeinstallprompt", function(e) {
  console.log("beforeinstallprompt event called");

  e.preventDefault();

  // save the event so it can be triggered later.
  deferredPrompt = e;

  function addToHomeScreen() {
    let myButton = document.querySelector(".my-prompt");

    myButton.style.display = "none";

    // Show the prompt
    deferredPrompt.prompt();

    // Wait for the user to respond to the prompt
    deferredPrompt.userChoice.then(function(choiceResult) {
      if (choiceResult.outcome === "accepted") {
        console.log("User accepted the prompt");
      } else {
        console.log("User dismissed the prompt");
      }

      deferredPrompt = null;
    });
  }

  // hiding
  let myButton = document.querySelector(".my-prompt");

  myButton.style.display = "block";
  myButton.addEventListener("click", addToHomeScreen);

  return false;
});

// Set this to true for production
var doCache = true;

// constants
const version = "0.1.0";
const cacheName = `toggle-me-${version}`;
const runtime = "runtime";

// A list of local resources we always want to be cached.
const cacheUrls = [
  "index.html",
  "./" // Alias for index.html
];

console.log("ServiceWorker start");
// dumb start

self.addEventListener("install", event => {
  let timeStamp = Date.now();

  console.log(`install-ing @ ${timeStamp}`);
  event.waitUntil(
    caches
      .open(cacheName)
      .then(cache => cache.addAll(cacheUrls))
      .then(self.skipWaiting())
  );
});

// The activate handler takes care of cleaning up old caches.
self.addEventListener("activate", event => {
  const currentCaches = [cacheName, runtime];
  event.waitUntil(
    caches
      .keys()
      .then(cacheNames => {
        return cacheNames.filter(
          cacheName => !currentCaches.includes(cacheName)
        );
      })
      .then(cachesToDelete => {
        return Promise.all(
          cachesToDelete.map(cacheToDelete => {
            return caches.delete(cacheToDelete);
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

// The fetch handler serves responses for same-origin resources from a cache.
// If no response is found, it populates the runtime cache with the response
// from the network before returning it to the page.
self.addEventListener("fetch", event => {
  // Skip cross-origin requests, like those for Google Analytics.
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then(cachedResponse => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return caches.open(runtime).then(cache => {
          return fetch(event.request).then(response => {
            // Put a copy of the response in the runtime cache.
            return cache.put(event.request, response.clone()).then(() => {
              return response;
            });
          });
        });
      })
    );
  }
});

// dumb end

// const { assets } = global.serviceWorkerOption;
//
// let assetsToCache = [...assets, "./"];
//
// assetsToCache = assetsToCache.map(path => {
//   return new URL(path, global.location).toString();
// });
//

// // Delete old caches that are not our current one!
// self.addEventListener("activate", event => {
//   const cacheWhitelist = [cacheName];
//   event.waitUntil(
//     caches.keys().then(keyList =>
//       Promise.all(
//         keyList.map(key => {
//           if (!cacheWhitelist.includes(key)) {
//             console.log("Deleting cache: " + key);
//             return caches.delete(key);
//           }
//         })
//       )
//     )
//   );
// });
//
// // self.addEventListener('install', () => self.skipWaiting());
// // self.addEventListener('activate', () => self.clients.claim());
//
// The first time the user starts up the PWA, 'install' is triggered.
// self.addEventListener("install", function(event) {
//   if (doCache) {
//     event.waitUntil(
//       caches.open(cacheName).then(function(cache) {
//         // Get the assets manifest so we can see what our js file is named
//         // This is because webpack hashes it
//         fetch("manifest.json")
//           .then(response => {
//             response.json();
//           })
//           .then(assets => {
//             // Open a cache and cache our files
//             // We want to cache the page and the main.js generated by webpack
//             // We could also cache any static assets like CSS or images
//             const urlsToCache = ["/", assets["main.js"]];
//             cache.addAll(urlsToCache);
//             console.log("cached");
//           });
//       })
//     );
//   }
// });
//
// // When the webpage goes to fetch files, we intercept that request and serve up the matching files
// // if we have them
// // self.addEventListener("fetch", function(event) {});
//
// // self.addEventListener("fetch", function(event) {
// //   if (doCache) {
// //     event.respondWith(
// //       caches.match(event.request).then(function(response) {
// //         return response || fetch(event.request);
// //       })
// //     );
// //   }
// // });
//
// self.addEventListener("fetch", function(event) {
//   console.log("removeAttributeHandling fetch event for", event.request.url);
//
//   event.respondWith(
//     caches.match(event.request).then(function(response) {
//       if (response) {
//         console.log("Found response in cache:", response);
//
//         return response;
//       }
//
//       console.log("No response found in cache. About to fetch from network...");
//
//       return fetch(event.request)
//         .then(function(response) {
//           console.log("Response from network is:", response);
//
//           return response;
//         })
//         .catch(function(error) {
//           console.error("Fetching failed:", error);
//
//           return caches.match("./index.html");
//         });
//     })
//   );
// });
//

// caching

// self.addEventListener("install", e => {
//   let timeStamp = Date.now();
//
//   console.log(`install-ing @ ${timeStamp}`);
//
//   e.waitUntil(
//     caches.open(cacheName).then(cache => {
//       return cache
//         .addAll([
//           `/`,
//           `/index.html`,
//           `/manifest.json`,
//           `/toggle-icon.png`,
//           `/toggle-icon-144.png`,
//           `/toggle-icon-white.png`
//         ])
//         .then(() => self.skipWaiting());
//     })
//   );
// });

// window.addEventListener("activate", event => {
//   event.waitUntil(window.clients.claim());
// });

// window.addEventListener("fetch", event => {
//   event.respondWith(
//     caches
//       .open(cacheName)
//       .then(cache => cache.match(event.request, { ignoreSearch: true }))
//       .then(response => {
//         return response || fetch(event.request);
//       })
//   );
// });

// let deferredPrompt = undefined;
//
// self.addEventListener("beforeinstallprompt", function(e) {
//   console.log("beforeinstallprompt Event fired");
//
//   e.preventDefault();
//
//   // save the event so it can be triggered later.
//   deferredPrompt = e;
//
//   function addToHomeScreen() {
//     let myButton = document.querySelector(".my-prompt");
//
//     myButton.style.display = "none";
//
//     // Show the prompt
//     deferredPrompt.prompt();
//
//     // Wait for the user to respond to the prompt
//     deferredPrompt.userChoice.then(function(choiceResult) {
//       if (choiceResult.outcome === "accepted") {
//         console.log("User accepted the prompt");
//       } else {
//         console.log("User dismissed the prompt");
//       }
//
//       deferredPrompt = null;
//     });
//   }
//
//   // hiding
//   let myButton = document.querySelector(".my-prompt");
//
//   myButton.style.display = "block";
//   myButton.addEventListener("click", addToHomeScreen);
//
//   return false;
// });
